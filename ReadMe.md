# Week 2 Lab: System Verilog

The reason for these different approches has to do with what kind of module is being tested. For the module in exercise 1, the task is to perform different tasks based on the opcode so to verify functionaility all possible opcodes need to be tested. For the module in exercise 2, the task is to coninuously perform a single function starting with the input, so to verify functionality it is enough to provide a few different inputs and verify the output is as expected over many cycles as it will end up testing the function on many different numbers. For the module in exercise 3, we perform a single function a single time so to sufficently test the module we need many different inputs, and it is best if they are random so edge cases aren't missed. 

The advantage of first kind of testing is that it tests every possible input to the system, thereby ensuring perfect functionality. However, for modules with lots of input combinations, the time required to test each and every possible input would be significant and potentially wasteful for modules that don't perform different functions for every input. The advantage of the second kind of testing is that it can test the module across a large verity of states while only requring testing of a few inputs. However, for modules that only perform one function on an input and then stop, the additional clock cycles are wasteful and the few starting inputs do not sufficently test the module. The advantage of the third kind of testing is that it can test a wide variety of inputs and edgecases without needed to test every single one. However, the reduced amount of tests means the potential to miss certain edgecases and for modules that perform a different function on every different input, the test cases are insufficent.
